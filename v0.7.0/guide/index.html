<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · BinaryTraits.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">BinaryTraits.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Motivation</a></li><li class="is-active"><a class="tocitem" href>User Guide</a><ul class="internal"><li><a class="tocitem" href="#Defining-traits-1"><span>Defining traits</span></a></li><li><a class="tocitem" href="#Assigning-traits-to-types-1"><span>Assigning traits to types</span></a></li><li><a class="tocitem" href="#Specifying-interfaces-1"><span>Specifying interfaces</span></a></li><li><a class="tocitem" href="#Notes-for-framework-providers-1"><span>Notes for framework providers</span></a></li><li><a class="tocitem" href="#Summary-1"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../concepts/">Concepts</a></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../design/">Under the hood</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tk3369/BinaryTraits.jl/blob/master/docs/src/guide.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Defining-traits-1"><a class="docs-heading-anchor" href="#Defining-traits-1">Defining traits</a><a class="docs-heading-anchor-permalink" href="#Defining-traits-1" title="Permalink"></a></h2><h3 id="The-@trait-macro-1"><a class="docs-heading-anchor" href="#The-@trait-macro-1">The @trait macro</a><a class="docs-heading-anchor-permalink" href="#The-@trait-macro-1" title="Permalink"></a></h3><p>You can define a new trait using the <code>@trait</code> macro. The syntax is described below:</p><pre><code class="language-julia">@trait &lt;TraitName&gt; [as &lt;SuperType&gt;] [prefix &lt;Can&gt;,&lt;Cannot&gt;] [with &lt;Trait1&gt;,&lt;Trait2&gt;,...]</code></pre><ul><li><code>&lt;TraitName&gt;</code>: an abstract type is defined with the same name</li><li><code>&lt;SuperType&gt;</code>: optional super-type of the trait&#39;s abstract type</li><li><code>&lt;Can&gt;</code> and <code>&lt;Cannot&gt;</code>: words that indicate whether a data type exhibits the trait or not</li><li><code>&lt;Trait1&gt;</code>, <code>&lt;Trait2&gt;</code>, etc. can be specified to define composite traits.</li></ul><p>The as-clause, prefix-clause, and with-clause are all optional.</p><h3 id="Specifying-super-type-for-trait-1"><a class="docs-heading-anchor" href="#Specifying-super-type-for-trait-1">Specifying super-type for trait</a><a class="docs-heading-anchor-permalink" href="#Specifying-super-type-for-trait-1" title="Permalink"></a></h3><p>The as-clause is used to specify the super-type of the trait type. If the clause is missing, the super-type is defaulted to <code>Any</code>. This may be useful when you want to group a set of traits under the same hierarchy.  For example:</p><pre><code class="language-julia">abstract type Ability end
@trait Fly as Ability
@trait Swim as Ability</code></pre><h3 id="Using-custom-prefixes-1"><a class="docs-heading-anchor" href="#Using-custom-prefixes-1">Using custom prefixes</a><a class="docs-heading-anchor-permalink" href="#Using-custom-prefixes-1" title="Permalink"></a></h3><p>When you define a trait using verbs like <em>Fly</em> or <em>Swim</em> in the above, it makes sense to define trait types with <code>Can</code> and <code>Cannot</code> prefixes.  But, what if you want to define a trait using a noun or an adjective? In that case, you can define your trait with the prefix-clause. For example:</p><pre><code class="language-julia">@trait Iterable prefix Is,Not</code></pre><p>Alternative, there are predefined trait prefixes from the BinaryTraits.Prefix sub-module. They are listed below for your convenience:</p><p>Trait prefixes as aliases of <code>Positive</code>:</p><ul><li><code>Can</code></li><li><code>Has</code></li><li><code>Is</code></li></ul><p>Traits prefixes as aliases of <code>Negative</code>:</p><ul><li><code>Cannot</code></li><li><code>No</code></li><li><code>Not</code></li><li><code>IsNot</code></li></ul><p>You may just import the pre-defined prefixes as you see fit.  The prefixes are</p><h3 id="Making-composite-traits-1"><a class="docs-heading-anchor" href="#Making-composite-traits-1">Making composite traits</a><a class="docs-heading-anchor-permalink" href="#Making-composite-traits-1" title="Permalink"></a></h3><p>Sometimes we really want to compose traits and use a single one directly for dispatch.  In that case, we can just use the with-clause like this:</p><pre><code class="language-julia">@trait FlySwim with Can{Fly}, Can{Swim}</code></pre><p>This above syntax would define a new trait where it assumes the positive side of the traits <code>Fly</code> and <code>Swim</code>.</p><p>A less common usage is to create trait types can is composed of both positive and negative traits.  Hence, you can define something like this:</p><pre><code class="language-julia">@trait SeaCreature with Can{Swim},Cannot{Fly}</code></pre><h2 id="Assigning-traits-to-types-1"><a class="docs-heading-anchor" href="#Assigning-traits-to-types-1">Assigning traits to types</a><a class="docs-heading-anchor-permalink" href="#Assigning-traits-to-types-1" title="Permalink"></a></h2><p>Once you define your favorite traits, you may assign any data type to any traits. The syntax of the assignment is as follows:</p><pre><code class="language-julia">@assign &lt;Type&gt; with &lt;Trait1&gt;,&lt;Trait2&gt;,...</code></pre><p>You can assign a data type with 1 or more positive (or negative) trait types in a single statement:</p><pre><code class="language-julia">struct Crane end
@assign Crane with Can{Fly},Can{Swim}</code></pre><p>Doing such assignment allows us to enforce interface contracts as you will see in the next section.</p><h2 id="Specifying-interfaces-1"><a class="docs-heading-anchor" href="#Specifying-interfaces-1">Specifying interfaces</a><a class="docs-heading-anchor-permalink" href="#Specifying-interfaces-1" title="Permalink"></a></h2><p>A ver useful feature of BinaryTraits is to define formal interfaces.  Currently, Julia does not come with any facility to specify interface contracts.  The users are expected to look up interface definitions from documentations and make sure that they implement those contracts per documentation accordingly.</p><p>This package provides additional machinery for users to formally define interfaces. It also comes with a macro for verifying the validity of data type implementations.</p><h3 id="Formal-interface-contracts-1"><a class="docs-heading-anchor" href="#Formal-interface-contracts-1">Formal interface contracts</a><a class="docs-heading-anchor-permalink" href="#Formal-interface-contracts-1" title="Permalink"></a></h3><p>Once you have defined a trait, you may define a set of interface contracts that a data type must implement in order to exhibit that trait.  These contracts are registered in the BinaryTraits system using the <code>@implement</code> macro. The syntax of <code>@implement</code> is as follows:</p><pre><code class="language-julia">@implement Positive{&lt;Trait&gt;} by &lt;FunctionSignature&gt;
@implement Negative{&lt;Trait&gt;} by &lt;FunctionSignature&gt;</code></pre><p>In general, the first form is what one normally use.  You are basically telling the system that a data type that exhibits the <code>Trait</code> must implement a function that is given the the <code>&lt;FunctionSignature&gt;</code>.</p><p>The words <code>Positive</code> and <code>Negative</code> are the standard parametric types for specifying the direction of the trait.  Alternatively, you may use the custom prefixes that you defined from the <code>@trait</code> macro.</p><p>Here are some examples:</p><pre><code class="language-julia">@implement Can{Fly} by liftoff(_)
@implement Can{Fly} by fly(_, direction::Float64, altitude::Float64)
@implement Can{Fly} by speed(_)::Float64</code></pre><p>The underscore <code>_</code> is a special syntax where you can indicate which positional argument you want to pass an object to the function.  The object is expected to have a type that is assigned to the <code>Fly</code> trait.</p><p>When return type is not specified, it is default to <code>Any</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The underscore may be placed at any argument position although it is quite common to leave it as the first argument.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you have multiple underscores, then the semantic is such that they are all of the same type.  For example, two ducks may exhibits a <code>Playful</code> trait and a <code>play(_, _)</code> interface expects an implementation of <code>play(::Duck, ::Duck)</code>.</p></div></div><p>Although not as common, it is also possible to use the negative part of the trait e.g. <code>Cannot{Fly}</code> for interface specification.</p><h3 id="Implementing-interface-contracts-1"><a class="docs-heading-anchor" href="#Implementing-interface-contracts-1">Implementing interface contracts</a><a class="docs-heading-anchor-permalink" href="#Implementing-interface-contracts-1" title="Permalink"></a></h3><p>A data type that is assigned to a trait should implement all interface contracts. From the previous section, we established three contracts for the <code>Fly</code> trait - <code>liftoff</code>, <code>fly</code>, and <code>speed</code>. To satisfy those contracts, we must implement those functions.</p><p>For example, let&#39;s say we are defining a <code>Bird</code> type that exhibits <code>Fly</code> trait, we can implement the following contracts:</p><pre><code class="language-julia">abstract type Animal end
struct Bird &lt;: Animal end
@assign Bird with Can{Fly}

# implmementation of Can{Fly} contracts
liftoff(bird::Bird) = &quot;Hoo hoo!&quot;
fly(bird::Bird, direction::Float64, altitude::Float64) = &quot;Getting there!&quot;
speed(bird::Bird) = 10.0</code></pre><h4 id="Using-Holy-Traits-pattern-1"><a class="docs-heading-anchor" href="#Using-Holy-Traits-pattern-1">Using Holy Traits pattern</a><a class="docs-heading-anchor-permalink" href="#Using-Holy-Traits-pattern-1" title="Permalink"></a></h4><p>Here, we implement the contracts directly with the specific concrete type. What if you have multiple types that satisfy the same trait. Holy Trait comes to rescue:</p><pre><code class="language-julia">liftoff(x::T) where T = liftoff(trait(Fly, T), x)
liftoff(::Can{Fly}, x) = &quot;Hi ho!&quot;
liftoff(::Cannot{Fly}, x) = &quot;baaa!&quot;</code></pre><p>This is nice but it should be nicer. BinaryTraits gives you a better syntax that generates the same code above:</p><pre><code class="language-julia">@traitfn liftoff(x::Can{Fly}) = &quot;Hi ho!&quot;
@traitfn liftoff(x::Cannot{Fly}) = &quot;baaa!&quot;</code></pre><p>So, there is no need to write the Holy Trait dispatch function anymore.</p><h4 id="Variance-1"><a class="docs-heading-anchor" href="#Variance-1">Variance</a><a class="docs-heading-anchor-permalink" href="#Variance-1" title="Permalink"></a></h4><p>When you specify abstract types in the interface contracts, the argument types are contra-variant and return type is covariant.  In simple terms, a function that satisfies the contract may have:</p><ul><li>argument types that are super-types of the types specified in the contract</li><li>return type that is a subtype of the return type specified in the contract</li></ul><p>For example, consider the following contract:</p><pre><code class="language-julia">accelerate(_, ::AbstractFloat)::AbstractFloat</code></pre><p>Then, the function below adheres to the contract because it can take any <code>Number</code> argument, which includes <code>AbstractFloat</code>.  Likewise, it returns a subtype of <code>AbstractFloat</code> and the caller of this interface should happily accept the result.</p><pre><code class="language-julia">accelerate(::Bird, ::Number) = 4.5</code></pre><h3 id="Validating-a-type-against-its-interfaces-1"><a class="docs-heading-anchor" href="#Validating-a-type-against-its-interfaces-1">Validating a type against its interfaces</a><a class="docs-heading-anchor-permalink" href="#Validating-a-type-against-its-interfaces-1" title="Permalink"></a></h3><p>The reason for spending so much effort in specifying interface contracts is so that we have a high confidence about our code.  Julia is a dynamic system and so generally speaking we do not have any static type checking in place. BinaryTraits now gives you that capability.</p><p>The <code>@check</code> macro can be used to verify whether your data type has fully implemented its assigned traits and respective interface contracts.  The usage is embarrassingly simple.  You can just call the <code>@check</code> macro with the data type:</p><pre><code class="language-julia">julia&gt; @check(Bird)
✅ Bird has no interface contract requirements.</code></pre><p>The <code>@check</code> macro returns an <code>InterfaceReview</code> object, which gives you the validation result.  The warnings are generated so that it comes up in the log file. The string representation of the <code>InterfaceReview</code> object is designed to clearly show you what has been implemented and what&#39;s not.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When you define composite traits, all contracts from the underlying traits must be implemented as well.  If you have a <code>FlySwim</code> trait, then all contracts specified for <code>Can{Fly}</code> and <code>Can{Swim}</code> are required even though you have not added any new contracts for <code>Can{FlySwim}</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>One way to utilize the <code>@check</code> macro is to put that in your module&#39;s <code>__init__</code> function so that it is verified before the package is used.  Another option is to do that in your test suite and so it will be run every single time.</p></div></div><h2 id="Notes-for-framework-providers-1"><a class="docs-heading-anchor" href="#Notes-for-framework-providers-1">Notes for framework providers</a><a class="docs-heading-anchor-permalink" href="#Notes-for-framework-providers-1" title="Permalink"></a></h2><p>BinaryTraits is designed to allow one module to define traits and interfaces and have other modules implementing them.  For example, it should be possible for <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> to define traits for row-oriented tables and column-oriented tables and the respective required interface functions, and then have its <a href="https://github.com/JuliaData/Tables.jl/blob/master/INTEGRATIONS.md">integrations</a> participate in the same traits system.</p><p>In order to facilitate interaction between modules, BinaryTraits requires the framework provider (e.g. Tables.jl in the example above) to add the following code in its <code>__init__</code> function:</p><pre><code class="language-julia">function __init__()
    init_traits(@__MODULE__)
end</code></pre><p>This additional step allows framework provider to register their traits and interface contracts at a central location. The integration packages can then verify their implementation against the interface at this same location.</p><h2 id="Summary-1"><a class="docs-heading-anchor" href="#Summary-1">Summary</a><a class="docs-heading-anchor-permalink" href="#Summary-1" title="Permalink"></a></h2><p>BinaryTraits is designed to fill the language gap as related to the lack of a formal traits and interface system.</p><p>The ability to design software with traits and interfaces and the ability to verify software for conformance to established interface contracts are highly desirable for professional software development projects.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Motivation</a><a class="docs-footer-nextpage" href="../concepts/">Concepts »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 25 November 2021 19:13">Thursday 25 November 2021</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
